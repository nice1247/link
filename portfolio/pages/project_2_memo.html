1. 성능 및 쿼리 최적화 관련
Q. 정산 통계 페이지의 로딩 속도를 3초에서 즉시 로딩으로 개선했다고 하셨는데, 
    구체적으로 어떤 쿼리 최적화 기법을 사용하셨나요?

답안 포인트: 단순한 '수정'이 아닌, 원인 분석 → 해결 방안 → 결과 순으로 답변하세요.

모범 답안: > "기존 쿼리는 대용량 정산 데이터를 처리할 때 인덱스를 타지 않는 서브쿼리가 다수 포함되어 있었고, 
        불필요한 전체 테이블 스캔(Full Table Scan)이 발생하고 있었습니다.
        우선 EXPLAIN을 통해 실행 계획을 분석하여 병목 지점을 파악했습니다. 
        이후 서브쿼리를 조인(Join) 구조로 변경하고, 통계에 자주 사용되는 날짜와 업체 ID 컬럼에 복합 인덱스를 적용했습니다. 
        또한, 모든 데이터를 매번 계산하는 대신 **일별 집계 테이블(Summary Table)**을 별도로 운영하는 방식을 도입하여 조회 성능을 극적으로 향상시켰습니다."



2. 보안 및 결제 무결성 관련
Q. 기존 QR 결제 방식에서 OTP 방식으로 전환한 이유는 무엇이며, 이로 인해 어떤 보안 취약점을 해결했나요?

답안 포인트: '복제 가능성'과 '유효 시간' 개념을 언급하세요.

모범 답안: > "기존 QR 코드는 한 번 생성되면 일정 시간 동안 고정되어 있어, 
        스크린샷 등을 통한 재사용(Replay Attack) 공격에 취약했습니다. 
        이를 해결하기 위해 TOTP(Time-based One-Time Password) 메커니즘을 도입했습니다.
        서버와 앱이 동기화된 알고리즘을 통해 30초마다 새로운 토큰을 생성하게 함으로써, 탈취된 정보가 즉시 무효화되도록 설계했습니다. 
        또한, 결제 직전 서버에서 해당 토큰의 사용 여부와 유효 시간을 검증하는 로직을 추가하여 결제 프로세스의 무결성을 강화했습니다."



3. 데이터 무결성 및 트랜잭션 관련
Q. 마일리지 결제 시스템에서 가장 중요한 것은 '잔액의 정확성'입니다. 결제 중 네트워크 오류가 발생하거나 중복 결제가 요청될 때 어떻게 대응하셨나요?

답안 포인트: 트랜잭션 관리와 원자성(Atomicity)을 강조하세요.

모범 답안: > "DB 트랜잭션의 원자성을 보장하기 위해 Spring의 @Transactional을 활용하여 
        '마일리지 차감'과 '결제 내역 생성'이 하나의 단위로 처리되도록 했습니다.
        중복 결제 방지를 위해서는 멱등성(Idempotency) 키를 도입했습니다. 
        결제 요청 시 고유한 요청 ID를 생성하여, 짧은 시간 내에 동일한 ID로 들어오는 요청은 서버 단에서 무시하도록 처리했습니다. 
        또한 SELECT FOR UPDATE 구문을 사용해 잔액 조회 시 **비관적 락(Pessimistic Lock)**을 걸어 
        동시성 이슈로 인한 오차를 원천 차단했습니다."



[deep dive]
1. 데이터베이스 동시성 제어 관련
질문: "마일리지 결제 시 여러 기기에서 동시에 결제가 일어날 때, '갱신 손실(Lost Update)' 문제를 어떻게 방지하셨나요?"

의도: 다중 사용자 환경에서 데이터 정합성을 유지하는 동시성 제어 능력을 확인하려는 질문입니다.

답변 전략: '비관적 락(Pessimistic Lock)'이나 '낙관적 락(Optimistic Lock)'의 개념을 언급하며 구체적으로 어떤 방식을 썼는지 답변하세요.

모범 답안: "결제 로직이 시작될 때 해당 사용자의 잔액 레코드에 SELECT ... FOR UPDATE를 사용하여 비관적 락을 걸었습니다.
        이를 통해 한 트랜잭션이 완료될 때까지 다른 트랜잭션이 잔액을 수정하거나 읽지 못하게 하여 데이터 정합성을 보장했습니다. 
        만약 성능 저하가 우려되는 단순 조회성 서비스였다면 버전(Version) 컬럼을 이용한 낙관적 락을 고려했겠지만, 
        금전적 데이터인 마일리지는 정확성이 최우선이라 판단하여 비관적 락을 선택했습니다."

        한명당 한 어플로 로그인하는 걸로 가정했을시 충돌의 경우는 거의 없다고 생각하고 낙관적 락으로 설계했습니다.
        만약 결제부분에서 좀 더 엄격하게 관리를 해야한다면 비관적 락으로 처리를 고려할 것이며 데드락 상태를 염두해야할 것입니다.

        

2. 예외 처리 및 트랜잭션 롤백 관련
질문: "결제 API 호출 중 마일리지는 차감되었는데, 카페 측 단말기 응답 지연으로 처리가 완료되지 않는 '미결제 상태'가 발생한다면 어떻게 처리하시겠습니까?"

의도: 분산 시스템(혹은 외부 연동)에서의 예외 처리와 트랜잭션 원자성(Atomicity)에 대한 이해를 묻는 질문입니다.

답변 전략: 보상 트랜잭션(Compensating Transaction)이나 타임아웃 처리를 언급하세요.

모범 답안: "네트워크 이슈나 타임아웃 발생 시 데이터 불일치를 해결하기 위해 '자동 롤백' 설정을 기본으로 하였습니다.
        하지만 API 응답을 받지 못한 모호한 상황(Timeout)에서는 즉시 취소 처리를 하기보다, 
        **결제 고유 ID(Transaction ID)**를 기반으로 서버에 재질의하는 로직을 두었습니다. 
        최종적으로 실패가 확정되면 차감된 마일리지를 다시 복구하는 보상 트랜잭션을 실행하거나, 
        관리자가 수동으로 대조할 수 있는 '대조 테이블'을 운영하여 운영 안정성을 확보했습니다."



3. 전자정부 표준 프레임워크(eGovFrame) 활용 관련
질문: "eGovFrame을 사용하면서 가장 큰 장점은 무엇이었으며, 프레임워크 내 어떤 공통 컴포넌트를 이 프로젝트에 활용하셨나요?"

의도: 단순히 도구를 사용하는 것을 넘어, 프레임워크의 구조를 이해하고 활용하는지 확인하려는 질문입니다.

답변 전략: Spring 기반의 구조적 이점과 보안/로그 공통 컴포넌트를 언급하세요.

모범 답안: "표준화된 아키텍처 덕분에 팀원들과 협업 시 코드 일관성을 유지하기 매우 좋았습니다. 
        특히 보안과 관련하여 'Spring Security 기반의 권한 관리' 컴포넌트를 활용해 관리자와 일반 사용자의 접근 제어를 손쉽게 구현했습니다. 
        또한, 모든 결제 요청과 쿼리 수행 시간을 기록하기 위해 **'AOP 기반의 로그 관리 컴포넌트'**를 적용했는데, 
        이것이 나중에 성능 병목 현상을 파악하고 쿼리 최적화 대상을 선정하는 데 큰 도움이 되었습니다."



4. 확장성 및 리팩토링 관련
질문: "사용자가 현재 1,500명에서 10만 명으로 늘어난다면, 현재의 결제 시스템 아키텍처에서 어떤 부분을 가장 먼저 개선해야 한다고 생각하시나요?"

의도: 시스템의 확장성(Scalability)과 아키텍처 설계 역량을 묻는 질문입니다.

답변 전략: DB 부하 분산(Read/Write 분리)이나 캐싱 전략을 제시하세요.

모범 답안: "사용자가 폭증하면 가장 먼저 DB IO 부하가 문제가 될 것입니다. 
        현재는 단일 DB를 사용 중이지만, 이후에는 Read-Replica를 구성하여 조회용(통계 등)과 쓰기용(결제) DB를 분리하겠습니다. 
        또한, 빈번하게 조회되는 사용자 정보나 가맹점 정보는 Redis와 같은 In-memory 캐시를 도입하여 DB 접근 횟수를 줄이겠습니다. 
        결제 요청이 몰리는 피크 타임에는 메시지 큐(Kafka/RabbitMQ)를 도입하여 비동기 방식으로 결제 처리를 분산시키는 구조를 검토하겠습니다."



5. 보안 기술(OTP/QR) 관련
질문: "OTP 방식이 보안상 유리하지만 사용자가 매번 번호를 입력해야 하는 불편함이 있을 텐데, 사용성(UX)을 높이기 위해 기술적으로 고민하신 부분이 있나요?"

의도: 보안과 사용자 경험 사이의 균형을 맞추는 능력을 확인하려는 질문입니다.

답변 전략: 자동화 로직이나 UI/UX적 배려를 설명하세요.

모범 답안: "사용자가 직접 6자리 숫자를 입력하는 번거로움을 줄이기 위해, 
        **OTP 토큰을 QR 코드 내에 임베딩(Embedding)**하는 방식을 사용했습니다. 
        사용자는 앱에서 QR만 보여주면 되고, 
        점주 단말기가 QR을 스캔할 때 내부에 포함된 OTP 값을 자동으로 서버로 전송하여 검증하게 설계했습니다. 
        이를 통해 사용자는 보안 강화 여부를 체감하지 못할 정도로 편리하게 결제하면서도, 
        서버 내부적으로는 매번 갱신되는 OTP 토큰을 검증하여 보안성을 확보했습니다."




💡 추가 면접 팁
eGovFrame 사용 이유: "공공 프로젝트의 표준을 준수하면서도, 이미 검증된 공통 컴포넌트를 활용해 결제 시스템의 핵심 로직(보안, 트랜잭션) 개발에 더 집중하기 위해 선택했다"고 답변하면 좋습니다.

사용자 수 증가(800명 → 1,500명): 숫자가 구체적이어서 좋습니다. "단순히 인원이 늘어난 것이 아니라, 특정 시간대(점심시간)에 트래픽이 몰리는 특성 때문에 성능 최적화가 필수적이었다"는 식의 상황 설명을 덧붙이면 더 전문적으로 보입니다.

실패 경험 준비: 만약 "개발 중 가장 힘들었던 점"을 묻는다면, OTP 도입 시 앱과 서버 간의 시간 동기화 오차로 인해 인증이 실패했던 사례와 이를 어떻게 해결(서버 시간 기준 오차 허용 범위 설정 등)했는지 준비해 보세요.