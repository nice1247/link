1. 성능 최적화: 커서 페이징 (Cursor-based Paging)
Q: 기존의 오프셋(Offset) 방식 대신 커서 페이징을 도입한 구체적인 이유와 그로 인한 성능 개선 효과는 어떠했나요?

답변 핵심: 오프셋 방식의 한계(Deep Page 조회 시 성능 저하)와 데이터 정합성 이슈 해결을 강조합니다.

모범 답안: > "전통적인 오프셋 방식은 뒤로 갈수록 DB가 읽어야 하는 레코드가 많아져 성능이 지수적으로 떨어지는 문제가 있었습니다. 
        특히 호국원 프로젝트처럼 예약 리스트가 지속적으로 쌓이는 시스템에서는 운영 시간이 길어질수록 병목이 될 것이라 판단했습니다.
        또한, 사용자가 1페이지를 보는 사이에 새로운 예약이 추가되면 2페이지에서 중복 데이터가 노출되는 '데이터 드리프트' 현상이 발생할 수 있었습니다. 
        이를 방지하기 위해 마지막 조회한 ID를 기준으로 다음 데이터를 가져오는 커서 페이징을 도입했습니다. 
        결과적으로 전체 데이터를 스캔하지 않고 인덱스를 직접 타격하게 되어, 
        데이터가 수십만 건 이상 쌓여도 일정한 조회 성능(O(1)에 가까운 속도)을 유지할 수 있었습니다."

        최초에 도입한 이유는 스크롤 방식의 페이지 이동방식으로 도입하였습니다.
        커서 페이징 방식으로 전환을 한 후 데이터 조회도 (체감상 0.5초 > 0.1초)미세하게 버벅거림없는 속도로 개선된 것을 확인할 수 있었습니다.




2. 실시간 통신: WebSocket & 사이니지
Q: 호출 시스템에 WebSocket을 사용하셨는데, 만약 네트워크 불안정으로 연결이 끊긴다면 사이니지 화면의 정합성을 어떻게 보장했나요?

답변 핵심: 실시간성(Push)과 안정성(Pull/Sync)의 조화를 설명합니다.

모범 답안: > "WebSocket은 서버에서 상태 변화를 즉시 전파하기 위한 최적의 선택이었지만, 
        사이니지 특성상 장시간 켜져 있어 연결이 끊길 리스크가 있었습니다. 
        이를 해결하기 위해 **'재연결 전략(Reconnection Strategy)'과 '상태 동기화(State Sync)'**를 함께 구현했습니다.
        연결이 끊기면 지수 백오프(Exponential Backoff) 방식으로 재연결을 시도하며, 
        재연결 성공 시점에는 현재 시점의 대기 목록 전체를 API로 다시 조회(REST)하여 상태를 갱신하도록 설계했습니다. 
        이를 통해 실시간성과 데이터의 최종 정합성을 동시에 확보할 수 있었습니다."



3. 보안 및 아키텍처: Custom JWT & API 단일화
Q: 웹, 앱, 키오스크 등 채널이 다양한데, Custom JWT를 설계할 때 채널별 권한 제어를 어떻게 처리했나요?

답변 핵심: 토큰 클레임(Claim)을 활용한 보안 설계와 확장성을 강조합니다.

모범 답안: > "채널마다 접근 가능한 리소스가 달랐기 때문에, 
        JWT의 페이로드(Payload)에 'Role'과 'Scope' 클레임을 커스텀하게 정의했습니다. 
        예를 들어, 관리자 사이니지용 토큰은 '호출' 권한만 갖고, 사용자 앱 토큰은 '예약/수정' 권한만 갖도록 분리했습니다.
        서버 측에서는 인터셉터(Interceptor)나 Spring Security를 통해 이 토큰의 클레임을 검증하여, 
        단일 API 엔드포인트를 유지하면서도 채널별로 세밀하게 접근을 통제했습니다. 
        덕분에 새로운 채널(예: 모바일 관리자용 앱)이 추가되더라도 
        기존 비즈니스 로직을 수정하지 않고 권한 설정만으로 대응할 수 있는 확장성을 확보했습니다."



4. 데이터 모델링: Non-PK 데이터 처리
Q: 고유키(PK)가 없는 데이터를 처리하기 위해 논리 키와 처리 규칙을 정의하셨다고 했는데, 구체적으로 어떤 상황이었고 어떻게 해결했나요?

답변 핵심: 비즈니스 규칙을 데이터 모델링으로 풀어내는 능력을 보여줍니다.

모범 답안: > "외부 연동 데이터 중 명확한 단일 PK 없이 조합으로만 식별해야 하는 데이터가 있었습니다. 
        이를 단순하게 처리하면 중복 데이터가 쌓이거나 수정 시 엉뚱한 레코드가 갱신될 위험이 있었습니다.
        저는 이를 위해 비즈니스적으로 중복될 수 없는 값들(예: 날짜 + 장소 코드 + 순번)을 조합해 '논리적 복합키'를 정의하고, 
        이를 기반으로 애플리케이션 레벨에서 유효성 검사를 수행했습니다. 
        또한, DB에 저장할 때는 내부적으로 관리용 Surrogate Key(인공키)를 발급하여 조인 성능을 높이고, 
        외부 시스템과의 연동 시에는 앞서 정의한 논리 규칙을 매핑 기준으로 삼아 데이터의 유일성과 무결성을 보장했습니다."



💡 면접 합격을 위한 추가 팁
"왜(Why)"에 집중: 기술 스택(Java, Spring, MySQL) 자체가 중요한 게 아니라, 왜 그 상황에서 그 기술을 썼는지가 중요합니다. (예: "성능 때문에 커서 페이징을 썼다")

트레이드 오프(Trade-off) 언급: "커서 페이징은 성능은 좋지만 특정 페이지로 직접 점프하는 기능 구현은 어렵다"는 식의 한계를 알고 있음을 언급하면 훨씬 전문적으로 보입니다.

PL로서의 시야: "민원을 줄이기 위해 실시간성을 강화했다"는 식의 비즈니스적 가치와 기술을 연결해 답변하세요.